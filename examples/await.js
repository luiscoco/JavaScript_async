'use strict';

// promisified setTimeout - we'll use this function later in our examples
function getPromise(time = 1000) {
	return new Promise((resolve) => {
		setTimeout(() => resolve('example promise result'), time);
	});
}

// ðŸ•® <ltc> 37554798-7e9d-4443-aee4-a1b6611758c8.md

// # `async` syntax for different function types
{
	async function funcDecName() {}

	const funcExprName = async function () {};

	const arrowFuncName = async () => {};

	const obj = {
		async method() {},
	};

	// (m) class ðŸ•® <ltc> 99e6c035-7b21-4cb4-9f57-bf13f03bf0bf.md
}

/* Inside an async function we can use 'await' keyword
it will await until the Promise to the right of it is settled, and then returns it's result
 */

{
	async function asyncFunction() {
		// with await syntax
		const number = await getPromise();
		console.log(number);

		const result = await getPromise(number * 1000); // will await until promise if fulfllled (*)
		console.log(result); // "ready!"

		// `.then` syntax equivalent:
		getPromise()
			.then((number) => {
				console.log(number);
			})
			.then((result) => console.log(result * 1000));
	}

	asyncFunction();
}

// ðŸ•® <cyberbiont> c4ec1ccf-2ebf-4bf1-9abc-99a907913987.md
// any function, that has 'async' keyword before its declaration, always automatically returns a promise (wraps the returned value in a promise)

// this means, to get the result from this such a function, we must use await or then
{
	async function asyncFunction() {
		// with await syntax
		const result = await getPromise();
		return result;
	}

	const result = await asyncFunction();
	console.log(result);
}

// -> adv async/await in-depth ðŸ•® <ltc> 328ce0af-d1e4-49b5-95e9-f3fcc999d36e.md

// -> top-level await ðŸ•® <ltc> 1f85900b-08cd-49c3-9f60-8699e5a25a42.md

// -> adv async/await errors handling ðŸ•® <ltc> 6decaa83-08e1-4be3-9e83-e467ec414ac2.md

// # errors handling

// 'await promise' "transforms" promise into simple sync code
// if promise was resolved successfully - result is returned

// if promise was rejected - error is thrown, cause 'throw new Error()' implicitly happens
async function runErrorsHandlingExamples() {
	{
		// that's why with async/await we handle errors using try / catch
		async function rejectsPromise() {
			try {
				await Promise.reject(new Error('Oops!'));
				// throw new Error('Oops!'); // effect is the same
			} catch (e) {
				console.log(e);
			}
		}
		// rejectsPromise(); // uncomment to run
	}

	{
		// errors on async function (if they were not caught inside it) we can handle on the outside with .catch
		async function rejectsPromise() {
			throw new Error('Oops!');
		}
		rejectsPromise().catch((err) => {
			console.log(err);
		});
	}

	{
		async function rejectsPromise() {
			// these 2 lines will do the same (cause rejectsPromise function to return a rejected promise)
			// await Promise.reject(new Error('Oops!')); // uncomment to run
			// throw new Error('Oops!'); // same effect
			// but without await Error will happen, but won't be caught and will cause the script to die
			// cause promise rejection will happen at the end of the cycle and catching code will run it happens
			await Promise.reject(new Error('Oops!')); // uncomment to see dying the script dying
		}
		rejectsPromise().catch((err) => {
			console.log(err);
		});
	}

	{
		// or, again with await + try / catch  - recommended (consistent with 'sync'-like async/await syntax)
		async function rejectsPromise() {
			await Promise.reject(new Error('Oops!'));
		}

		try {
			await rejectsPromise();
		} catch (e) {
			console.log(e);
		}
	}
}
runErrorsHandlingExamples(); // uncomment to run

// # chained promises
/* if we return a promise from async function, it will be 'chained' with the promise, generated by async function
If the function in the .then handler (or 'async' function) returns a value, then the Promise resolves with that value.
If the .then handler (or 'async' function) returns another Promise, then the original Promise resolves with the resolved value of the chained Promise.
if the chained Promise is still pending, returned Promise will be pending too until the chained promise is resolved
*/

{
	async function asyncFunction() {
		const promise = new Promise((resolve, reject) =>
			setTimeout(() => resolve('some result'), 2000)
		);
		console.log(promise); /* Promise { <pending> } */
		return promise;
	}

	const resultingPromise = asyncFunction();

	console.log(resultingPromise); /* Promise { <pending> } */

	setTimeout(
		() =>
			console.log(
				'by this moment the chained promise from line 123 was resolved, and so the resulting promise',
				resultingPromise
			),
		3000
	);

	// to get the actual value from promise, we need to use await
	// this line will await until the Promise resolves (2000 ms) and then print the result
	console.log(await resultingPromise); // some result
}

// fetch example ðŸ•® <ltc> 3c1344a0-d037-475e-b889-16d73e9a08d7.md
